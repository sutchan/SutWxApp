/**
 * 文件名: 02-功能模块说明文档.md
 * 版本号: 1.0.0
 * 更新日期: 2025-11-23
 * 描述: 02-功能模块说明文档 文档文件
 */
# 功能模块说明文档

**版本**: 1.0.16  
**最后更新**: 2024年11月1日

## 1. 概述
本文档汇总 SutWxApp 的主要功能模块、依赖关系、数据流与接口约定，作为开发与协作的总览参考。

## 2. 模块清单
- 用户与认证：注册/登录、资料、权限、Token 管理。
- 内容与文章：文章列表/详情、评论、收藏、分享。
- 商品与分类：商品详情、规格、库存、分类管理。
- 购物车：增删改查、价格计算、优惠叠加策略。
- 订单管理：创建、支付、发货、售后、退款。
- 支付中心：微信支付、支付状态回调、对账。
- 积分系统：获取/消耗/抵扣/过期与风控（见《积分系统功能说明》）。
- 会员体系：等级、权益、成长值、升级规则。
- 消息中心：站内消息、模板消息、订阅消息。
- 活动运营：优惠券、满减、秒杀、拼团、抽奖。
- 客服与工单：在线客服、问题工单、反馈处理。
- 多语言支持：国际化 `.po/.pot` 字符串维护与一致性。

## 3. 依赖关系（示例）
- 订单依赖：商品、库存、价格、优惠、支付、积分。
- 支付依赖：订单、用户、风控、消息通知。
- 积分依赖：订单事件、任务中心、活动配置、会员体系。
- 会员依赖：积分、订单、活动。

## 4. 数据流与事件
- 下单：购物车→订单→支付→发货→完成→（积分发放/会员成长）。
- 售后：退款→库存回滚→积分回退/冻结→消息通知。
- 任务：用户行为事件→校验限频→发放积分/权益→记录流水。

## 5. 接口约定
统一参考 `docs/03-开发者指南/03-API接口文档.md`，各模块应：
- 使用 RESTful 设计、统一响应格式与错误码。
- 明确认证与权限边界（RBAC）。
- 提供分页、过滤、排序能力。
- 关键写操作需幂等与审计日志。

## 6. 配置与开关
- 运营开关：活动、券、任务、积分抵扣、消息发送。
- 策略配置：积分倍率、支付限额、风控策略、黑白名单。
- 灰度发布：按用户/地区/版本进行开关控制。

## 7. 性能与可靠性
- 缓存：热点数据缓存、列表分页缓存、限频状态缓存。
- 异步：消息与事件队列、批处理任务（过期、清理）。
- 可靠性：事务/锁/幂等、重试与告警、降级策略。

## 8. 测试建议
- 单元测试：服务与工具函数、规则校验。
- 集成测试：下单/支付/售后闭环、积分变更与回退。
- 接口测试：认证、权限、错误码与边界。
- 性能测试：并发下单/支付、批处理任务压力测试。

## 9. 风险与边界
- 金融相关：支付/退款严格对账、异常回退。
- 风控：积分刷取、防套利、设备指纹与限频。
- 数据一致性：并发扣减、库存与积分一致性治理。

## 10. 版本演进（示例）
- v1：核心电商闭环与基础积分。
- v2：会员权益、活动矩阵与消息中心。
- v3：性能扩展与风控体系完善。

## 11. 模块详细说明

### 11.1 用户与认证模块

#### 核心功能
- 用户注册：支持手机号、微信授权等多种注册方式
- 用户登录：密码登录、验证码登录、微信授权登录
- 个人资料管理：基本信息、头像、收货地址等
- 权限管理：基于角色的访问控制(RBAC)
- Token管理：JWT令牌生成、验证、刷新

#### 技术实现
```javascript
// 用户登录示例
async function login(credentials) {
  // 1. 验证用户凭据
  const user = await userService.validateCredentials(credentials);
  
  // 2. 生成JWT令牌
  const token = jwt.sign({ userId: user.id }, SECRET_KEY, { expiresIn: '7d' });
  
  // 3. 更新最后登录时间
  await userService.updateLastLogin(user.id);
  
  // 4. 返回用户信息和令牌
  return {
    user: sanitizeUser(user),
    token: token,
    expiresIn: 604800 // 7天
  };
}
```

#### 关键接口
- `POST /api/auth/login` - 用户登录
- `POST /api/auth/register` - 用户注册
- `POST /api/auth/refresh` - 刷新令牌
- `GET /api/user/profile` - 获取用户资料
- `PUT /api/user/profile` - 更新用户资料

### 11.2 商品与分类模块

#### 核心功能
- 商品管理：商品信息、规格、库存、价格
- 分类管理：多级分类、分类属性
- 商品搜索：关键词搜索、筛选、排序
- 商品推荐：基于用户行为的个性化推荐

#### 技术实现
```javascript
// 商品搜索服务示例
class ProductService {
  async searchProducts(params) {
    const {
      keyword,
      categoryId,
      minPrice,
      maxPrice,
      sortBy = 'created_at',
      sortOrder = 'desc',
      page = 1,
      pageSize = 20
    } = params;
    
    // 构建查询条件
    const query = {};
    
    if (keyword) {
      query.$or = [
        { name: { $regex: keyword, $options: 'i' } },
        { description: { $regex: keyword, $options: 'i' } }
      ];
    }
    
    if (categoryId) {
      query.categoryId = categoryId;
    }
    
    if (minPrice !== undefined || maxPrice !== undefined) {
      query.price = {};
      if (minPrice !== undefined) query.price.$gte = minPrice;
      if (maxPrice !== undefined) query.price.$lte = maxPrice;
    }
    
    // 执行查询
    const products = await Product.find(query)
      .sort({ [sortBy]: sortOrder === 'desc' ? -1 : 1 })
      .skip((page - 1) * pageSize)
      .limit(pageSize)
      .populate('categoryId', 'name');
    
    // 获取总数
    const total = await Product.countDocuments(query);
    
    return {
      products,
      pagination: {
        page,
        pageSize,
        total,
        pages: Math.ceil(total / pageSize)
      }
    };
  }
}
```

#### 关键接口
- `GET /api/products` - 获取商品列表
- `GET /api/products/:id` - 获取商品详情
- `GET /api/categories` - 获取分类列表
- `GET /api/products/search` - 搜索商品

### 11.3 购物车模块

#### 核心功能
- 商品添加：将商品加入购物车
- 数量修改：增减购物车中商品数量
- 商品删除：从购物车移除商品
- 价格计算：实时计算购物车总价
- 优惠应用：应用优惠券、满减等优惠

#### 技术实现
```javascript
// 购物车服务示例
class CartService {
  async addToCart(userId, productId, quantity, specs = {}) {
    // 1. 验证商品是否存在且有库存
    const product = await productService.getProductById(productId);
    if (!product || product.stock < quantity) {
      throw new Error('商品不存在或库存不足');
    }
    
    // 2. 查找用户购物车中是否已有该商品
    let cartItem = await Cart.findOne({
      userId,
      productId,
      specs: { $eq: specs }
    });
    
    if (cartItem) {
      // 3. 如果已存在，更新数量
      const newQuantity = cartItem.quantity + quantity;
      if (newQuantity > product.stock) {
        throw new Error('超出商品库存数量');
      }
      
      cartItem.quantity = newQuantity;
      await cartItem.save();
    } else {
      // 4. 如果不存在，创建新购物车项
      cartItem = new Cart({
        userId,
        productId,
        quantity,
        specs,
        price: product.price,
        addedAt: new Date()
      });
      
      await cartItem.save();
    }
    
    // 5. 返回更新后的购物车
    return this.getCartByUserId(userId);
  }
  
  async calculateCartTotal(userId) {
    const cartItems = await Cart.find({ userId }).populate('productId');
    
    let subtotal = 0;
    let discount = 0;
    
    // 计算商品总价
    for (const item of cartItems) {
      subtotal += item.productId.price * item.quantity;
    }
    
    // 应用优惠券
    const coupon = await couponService.getBestAvailableCoupon(userId, subtotal);
    if (coupon) {
      discount = couponService.calculateDiscount(coupon, subtotal);
    }
    
    // 计算最终总价
    const total = Math.max(0, subtotal - discount);
    
    return {
      subtotal,
      discount,
      total,
      coupon: coupon ? {
        id: coupon.id,
        code: coupon.code,
        discount: discount
      } : null
    };
  }
}
```

#### 关键接口
- `POST /api/cart/items` - 添加商品到购物车
- `PUT /api/cart/items/:id` - 更新购物车商品数量
- `DELETE /api/cart/items/:id` - 从购物车删除商品
- `GET /api/cart` - 获取用户购物车
- `POST /api/cart/apply-coupon` - 应用优惠券

### 11.4 订单管理模块

#### 核心功能
- 订单创建：从购物车生成订单
- 订单支付：集成微信支付
- 订单状态管理：待支付、已支付、已发货、已完成、已取消等
- 订单查询：用户订单列表、订单详情
- 售后处理：退款、退货、换货

#### 技术实现
```javascript
// 订单服务示例
class OrderService {
  async createOrder(userId, addressId, items, couponId = null) {
    // 1. 验证用户地址
    const address = await addressService.getAddressById(addressId);
    if (!address || address.userId.toString() !== userId) {
      throw new Error('无效的收货地址');
    }
    
    // 2. 验证商品并计算价格
    let subtotal = 0;
    const orderItems = [];
    
    for (const item of items) {
      const product = await productService.getProductById(item.productId);
      
      if (!product || product.stock < item.quantity) {
        throw new Error(`商品 ${product.name} 库存不足`);
      }
      
      const itemTotal = product.price * item.quantity;
      subtotal += itemTotal;
      
      orderItems.push({
        productId: item.productId,
        quantity: item.quantity,
        price: product.price,
        total: itemTotal,
        specs: item.specs || {}
      });
    }
    
    // 3. 应用优惠券
    let discount = 0;
    let coupon = null;
    
    if (couponId) {
      coupon = await couponService.getCouponById(couponId);
      if (coupon && couponService.canUseCoupon(coupon, userId, subtotal)) {
        discount = couponService.calculateDiscount(coupon, subtotal);
      }
    }
    
    // 4. 计算运费和总价
    const shipping = this.calculateShipping(subtotal);
    const total = Math.max(0, subtotal - discount + shipping);
    
    // 5. 创建订单
    const order = new Order({
      orderNo: this.generateOrderNo(),
      userId,
      items: orderItems,
      address: {
        name: address.name,
        phone: address.phone,
        province: address.province,
        city: address.city,
        district: address.district,
        detail: address.detail
      },
      subtotal,
      discount,
      shipping,
      total,
      coupon: coupon ? {
        id: coupon.id,
        code: coupon.code,
        discount: discount
      } : null,
      status: 'pending_payment',
      createdAt: new Date()
    });
    
    await order.save();
    
    // 6. 扣减商品库存
    for (const item of orderItems) {
      await productService.decreaseStock(item.productId, item.quantity);
    }
    
    // 7. 如果使用了优惠券，标记为已使用
    if (coupon) {
      await couponService.markCouponAsUsed(coupon.id, userId, order.id);
    }
    
    return order;
  }
  
  generateOrderNo() {
    const date = new Date();
    const dateStr = date.getFullYear().toString() +
      (date.getMonth() + 1).toString().padStart(2, '0') +
      date.getDate().toString().padStart(2, '0');
    
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    
    return `${dateStr}${random}`;
  }
}
```

#### 关键接口
- `POST /api/orders` - 创建订单
- `GET /api/orders` - 获取用户订单列表
- `GET /api/orders/:id` - 获取订单详情
- `POST /api/orders/:id/pay` - 支付订单
- `POST /api/orders/:id/cancel` - 取消订单
- `POST /api/orders/:id/refund` - 申请退款

### 11.5 支付中心模块

#### 核心功能
- 微信支付：集成微信支付API
- 支付回调：处理微信支付结果通知
- 支付状态查询：查询订单支付状态
- 退款处理：处理退款请求和结果
- 对账功能：定期对账确保数据一致性

#### 技术实现
```javascript
// 支付服务示例
class PaymentService {
  async createPayment(orderId) {
    // 1. 获取订单信息
    const order = await orderService.getOrderById(orderId);
    if (!order || order.status !== 'pending_payment') {
      throw new Error('订单不存在或状态不正确');
    }
    
    // 2. 调用微信支付统一下单API
    const paymentParams = {
      appid: config.wechat.appId,
      mch_id: config.wechat.mchId,
      nonce_str: this.generateNonceStr(),
      body: `SutWxApp订单-${order.orderNo}`,
      out_trade_no: order.orderNo,
      total_fee: Math.round(order.total * 100), // 转换为分
      spbill_create_ip: this.getClientIP(),
      notify_url: config.wechat.paymentNotifyUrl,
      trade_type: 'JSAPI',
      openid: order.userOpenId
    };
    
    // 3. 添加签名
    paymentParams.sign = this.generateSign(paymentParams);
    
    // 4. 调用微信支付API
    const response = await this.callWechatPayAPI(paymentParams);
    
    if (response.return_code !== 'SUCCESS' || response.result_code !== 'SUCCESS') {
      throw new Error(`微信支付失败: ${response.return_msg || response.err_code_des}`);
    }
    
    // 5. 生成前端支付参数
    const paymentParamsForFrontend = {
      appId: paymentParams.appid,
      timeStamp: Math.floor(Date.now() / 1000).toString(),
      nonceStr: this.generateNonceStr(),
      package: `prepay_id=${response.prepay_id}`,
      signType: 'MD5'
    };
    
    // 6. 添加前端签名
    paymentParamsForFrontend.paySign = this.generateSign(paymentParamsForFrontend);
    
    // 7. 保存支付记录
    const payment = new Payment({
      orderId,
      orderNo: order.orderNo,
      paymentNo: response.prepay_id,
      amount: order.total,
      status: 'pending',
      paymentMethod: 'wechat',
      createdAt: new Date()
    });
    
    await payment.save();
    
    return paymentParamsForFrontend;
  }
  
  async handlePaymentNotify(notifyData) {
    // 1. 验证签名
    if (!this.verifyNotifySign(notifyData)) {
      throw new Error('支付通知签名验证失败');
    }
    
    // 2. 查找支付记录
    const payment = await Payment.findOne({
      orderNo: notifyData.out_trade_no
    });
    
    if (!payment) {
      throw new Error('支付记录不存在');
    }
    
    // 3. 更新支付状态
    if (notifyData.result_code === 'SUCCESS' && notifyData.return_code === 'SUCCESS') {
      payment.status = 'paid';
      payment.transactionId = notifyData.transaction_id;
      payment.paidAt = new Date();
      await payment.save();
      
      // 4. 更新订单状态
      await orderService.updateOrderStatus(payment.orderId, 'paid');
      
      // 5. 发送支付成功通知
      await notificationService.sendPaymentSuccessNotification(payment.orderId);
      
      // 6. 发放积分
      await pointsService.awardPointsForOrder(payment.orderId);
    } else {
      payment.status = 'failed';
      payment.failureReason = notifyData.err_code_des || notifyData.return_msg;
      await payment.save();
      
      // 7. 恢复商品库存
      await orderService.restoreProductStock(payment.orderId);
    }
    
    return { success: true };
  }
}
```

#### 关键接口
- `POST /api/payments` - 创建支付
- `POST /api/payments/notify` - 支付回调通知
- `GET /api/payments/:id/status` - 查询支付状态
- `POST /api/payments/:id/refund` - 申请退款
- `GET /api/payments/reconciliation` - 对账接口

### 11.6 积分系统模块

#### 核心功能
- 积分获取：签到、任务、购物等获取积分
- 积分消耗：兑换商品、抵扣现金等
- 积分过期：设置积分有效期并自动过期
- 积分历史：记录用户积分变动历史
- 积分任务：设置积分获取任务

#### 技术实现
```javascript
// 积分服务示例
class PointsService {
  async awardPoints(userId, points, reason, relatedId = null, type = 'reward') {
    // 1. 验证参数
    if (points <= 0) {
      throw new Error('积分数必须大于0');
    }
    
    // 2. 创建积分记录
    const pointsRecord = new Points({
      userId,
      points,
      reason,
      relatedId,
      type,
      status: 'active',
      createdAt: new Date(),
      expiresAt: this.calculateExpiryDate() // 计算过期时间
    });
    
    await pointsRecord.save();
    
    // 3. 更新用户总积分
    await userService.updateUserPoints(userId, points);
    
    // 4. 发送积分变动通知
    await notificationService.sendPointsChangeNotification(userId, points, reason);
    
    return pointsRecord;
  }
  
  async consumePoints(userId, points, reason, relatedId = null) {
    // 1. 验证用户积分是否足够
    const user = await userService.getUserById(userId);
    if (user.points < points) {
      throw new Error('积分不足');
    }
    
    // 2. 获取用户可用的积分记录（按过期时间排序，先使用即将过期的）
    const availablePoints = await Points.find({
      userId,
      status: 'active',
      expiresAt: { $gt: new Date() }
    }).sort({ expiresAt: 1 });
    
    // 3. 计算需要消耗的积分记录
    let remainingPoints = points;
    const consumedRecords = [];
    
    for (const record of availablePoints) {
      if (remainingPoints <= 0) break;
      
      const consumeAmount = Math.min(record.points, remainingPoints);
      
      // 如果消耗部分积分，需要拆分记录
      if (consumeAmount < record.points) {
        // 创建新的记录表示剩余积分
        const remainingRecord = new Points({
          userId,
          points: record.points - consumeAmount,
          reason: record.reason,
          relatedId: record.relatedId,
          type: record.type,
          status: 'active',
          createdAt: record.createdAt,
          expiresAt: record.expiresAt
        });
        
        await remainingRecord.save();
      }
      
      // 更新原记录为已消耗
      record.points = consumeAmount;
      record.status = 'consumed';
      record.consumedAt = new Date();
      record.consumeReason = reason;
      record.consumeRelatedId = relatedId;
      
      await record.save();
      
      consumedRecords.push(record);
      remainingPoints -= consumeAmount;
    }
    
    // 4. 更新用户总积分
    await userService.updateUserPoints(userId, -points);
    
    // 5. 创建积分消耗记录
    const consumeRecord = new Points({
      userId,
      points: -points,
      reason,
      relatedId,
      type: 'consume',
      status: 'consumed',
      createdAt: new Date(),
      consumedAt: new Date(),
      consumeReason: reason,
      consumeRelatedId: relatedId
    });
    
    await consumeRecord.save();
    
    // 6. 发送积分变动通知
    await notificationService.sendPointsChangeNotification(userId, -points, reason);
    
    return {
      consumedRecords,
      totalConsumed: points
    };
  }
  
  async expirePoints() {
    // 1. 查找所有过期的积分记录
    const expiredPoints = await Points.find({
      status: 'active',
      expiresAt: { $lte: new Date() }
    });
    
    // 2. 按用户分组
    const expiredByUser = {};
    for (const record of expiredPoints) {
      if (!expiredByUser[record.userId]) {
        expiredByUser[record.userId] = [];
      }
      expiredByUser[record.userId].push(record);
    }
    
    // 3. 批量处理过期积分
    for (const userId in expiredByUser) {
      const userExpiredPoints = expiredByUser[userId];
      let totalExpired = 0;
      
      // 更新积分记录状态
      for (const record of userExpiredPoints) {
        record.status = 'expired';
        record.expiredAt = new Date();
        await record.save();
        
        totalExpired += record.points;
      }
      
      // 更新用户总积分
      await userService.updateUserPoints(userId, -totalExpired);
      
      // 发送过期通知
      await notificationService.sendPointsExpiredNotification(userId, totalExpired);
    }
    
    return {
      expiredCount: expiredPoints.length,
      expiredUsers: Object.keys(expiredByUser).length
    };
  }
}
```

#### 关键接口
- `POST /api/points/award` - 奖励积分
- `POST /api/points/consume` - 消耗积分
- `GET /api/points/history` - 获取积分历史
- `GET /api/points/tasks` - 获取积分任务列表
- `POST /api/points/signin` - 签到获取积分

## 版本历史

| 版本号 | 更新日期 | 更新内容 |
|--------|----------|----------|
| 1.0.16 | 2024-11-01 | 添加版本号和最后更新时间，完善模块详细说明 |
| 1.0.15 | 2024-10-25 | 添加积分系统模块详细说明 |
| 1.0.14 | 2024-10-20 | 添加支付中心模块详细说明 |
| 1.0.13 | 2024-10-15 | 添加订单管理模块详细说明 |
| 1.0.12 | 2024-10-10 | 添加购物车模块详细说明 |
| 1.0.11 | 2024-10-05 | 添加商品与分类模块详细说明 |
| 1.0.10 | 2024-09-30 | 添加用户与认证模块详细说明 |
| 1.0.9 | 2024-09-25 | 完善风险与边界说明 |
| 1.0.8 | 2024-09-20 | 更新测试建议 |
| 1.0.7 | 2024-09-15 | 添加性能与可靠性说明 |
| 1.0.6 | 2024-09-10 | 完善配置与开关说明 |
| 1.0.5 | 2024-09-05 | 更新接口约定 |
| 1.0.4 | 2024-08-30 | 完善数据流与事件 |
| 1.0.3 | 2024-08-25 | 添加依赖关系说明 |
| 1.0.2 | 2024-08-20 | 完善模块清单 |
| 1.0.1 | 2024-08-15 | 初始版本 |